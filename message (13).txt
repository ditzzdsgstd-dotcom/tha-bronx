local uis = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local existingGui = game.CoreGui:FindFirstChild("CustomScreenGui")
if existingGui then existingGui:Destroy() end

local ScreenGui = Instance.new("ScreenGui", game.CoreGui)
ScreenGui.Name = "CustomScreenGui"
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local Frame = Instance.new("Frame")
Frame.Name = "DraggableToggle"
Frame.Parent = ScreenGui
Frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(1, -120, 0, 30)
Frame.Size = UDim2.new(0, 60, 0, 60)

local imageLabel = Instance.new("ImageLabel")
imageLabel.Parent = Frame
imageLabel.Size = UDim2.new(1, 0, 1, 0)
imageLabel.Position = UDim2.new(0, 0, 0, 0)
imageLabel.Image = "rbxassetid://112029241653427" -- Replace with any icon if needed
imageLabel.BackgroundTransparency = 1

local TextButton = Instance.new("TextButton")
TextButton.Parent = imageLabel
TextButton.BackgroundTransparency = 1
TextButton.Size = UDim2.new(1, 0, 1, 0)
TextButton.Text = ""

-- Glow effect
local glowStroke = Instance.new("UIStroke", Frame)
glowStroke.Thickness = 3
glowStroke.Transparency = 0.8
glowStroke.Color = Color3.fromRGB(77, 251, 16)

local gradient = Instance.new("UIGradient", glowStroke)
gradient.Color = ColorSequence.new {
	ColorSequenceKeypoint.new(0, Color3.fromRGB(77, 251, 16)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 20, 147))
}
gradient.Rotation = 45

-- Glow animation
local function createGlowEffect(stroke)
	local glowTweenInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
	local tween = TweenService:Create(stroke, glowTweenInfo, {
		Transparency = 0.1,
		Thickness = 5
	})
	tween:Play()
end

createGlowEffect(glowStroke)

-- Dragging functionality
local function makeDraggable(frame)
	local dragging, dragStart, startPos, conn

	local function beginDrag(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			dragStart = input.Position
			startPos = frame.Position

			if conn then conn:Disconnect() end
			conn = uis.InputChanged:Connect(function(newInput)
				if newInput.UserInputType == Enum.UserInputType.MouseMovement then
					local delta = newInput.Position - dragStart
					frame.Position = UDim2.new(
						startPos.X.Scale, startPos.X.Offset + delta.X,
						startPos.Y.Scale, startPos.Y.Offset + delta.Y
					)
				end
			end)
		end
	end

	local function endDrag()
		dragging = false
		if conn then conn:Disconnect() conn = nil end
	end

	frame.InputBegan:Connect(beginDrag)
	frame.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			endDrag()
		end
	end)

	uis.InputEnded:Connect(function(input)
		if dragging and input.UserInputType == Enum.UserInputType.MouseButton1 then
			endDrag()
		end
	end)
end

makeDraggable(Frame)

local Bracket = loadstring(game:HttpGet("https://raw.githubusercontent.com/Luarm0r/bracket/refs/heads/main/v3.2"))()
local executor = identifyexecutor and identifyexecutor() or "Unknown Executor"

local Window = Bracket:Window({
    Name = "X-Dk V2 | Tha Bronx | " .. executor,
    Enabled = true,
    Color = Color3.fromRGB(0, 255, 0),
    Size = UDim2.new(0, 320, 0, 240),
    Position = UDim2.new(0.5, -160, 0.5, -120)
})

-- Toggle Bracket UI
local visible = true
TextButton.MouseButton1Click:Connect(function()
	visible = not visible
	Window:Toggle(visible)
end)

local Tab = Window:Tab({Name = "Main"})

local DupeSection = Tab:Section({Name = "Dupe", Side = "Left"})

DupeSection:Divider({Text = "Duping Guide",Side = "Left"})

DupeSection:Divider({Text = "Money Dupe",Side = "Left"})

DupeSection:Label({Text = "1. Press 'Purchase Ice-Fruitz-Cupz' Then Teleport To Cook Pot" })
DupeSection:Label({Text = "2. Then Cook Your ice Fruitz wait 60+ Seconds for it to cook"})
DupeSection:Label({Text = "3. When cooked press 'Money Dupe'"})

DupeSection:Divider({Text = "Gun Dupe",Side = "Left"})

DupeSection:Label({Text = "1. Equip your Item you want to duplicate"})
DupeSection:Label({Text = "2. Press 'Duplicate Gun' If dont work keep trying"})

DupeSection:Divider({Text = "Buttons",Side = "Left"})

DupeSection:Button({
    Name = "Duplicate Gun",
    Callback = function()
        local ReplicatedStorage = cloneref(game:GetService("ReplicatedStorage"))
        local Players = cloneref(game:GetService("Players"))

        local Player = Players.LocalPlayer
        local Character = Player.Character or Player.CharacterAdded:Wait()
        local Backpack = Player:WaitForChild("Backpack")

        local Tool = Character:FindFirstChildOfClass("Tool")
        if not Tool then return end

        Tool.Parent = Backpack
        task.wait(0.5)

        local ToolName = Tool.Name
        local ToolId = nil

        local function getPing()
            if typeof(Player.GetNetworkPing) == "function" then
                local success, result = pcall(function()
                    return tonumber(string.match(Player:GetNetworkPing(), "%d+"))
                end)
                if success and result then
                    return result
                end
            end

            local success2, pingStat = pcall(function()
                return Players.LocalPlayer:FindFirstChild("PlayerGui"):FindFirstChild("Ping") or
                    Players.LocalPlayer:FindFirstChild("PlayerScripts"):FindFirstChild("Ping")
            end)
            if success2 and pingStat and pingStat:IsA("TextLabel") then
                local num = tonumber(string.match(pingStat.Text, "%d+"))
                if num then
                    return num
                end
            end

            local t0 = tick()
            local temp = Instance.new("BoolValue", ReplicatedStorage)
            temp.Name = "PingTest_" .. tostring(math.random(10000, 99999))
            task.wait(0.1)
            local t1 = tick()
            temp:Destroy()

            return math.clamp((t1 - t0) * 1000, 50, 300)
        end

        local ping = getPing()
        local delay = 0.25 + ((math.clamp(ping, 0, 300) / 300) * 0.03)

        local marketconnection = ReplicatedStorage.MarketItems.ChildAdded:Connect(function(item)
            if item.Name == ToolName then
                local owner = item:WaitForChild("owner", 2)
                if owner and owner.Value == Player.Name then
                    ToolId = item:GetAttribute("SpecialId")
                end
            end
        end)

        task.spawn(function()
            ReplicatedStorage.ListWeaponRemote:FireServer(ToolName, 99999)
        end)

        task.wait(delay)

        task.spawn(function()
            ReplicatedStorage.BackpackRemote:InvokeServer("Store", ToolName)
        end)

        task.wait(3)

        if ToolId then
            task.spawn(function()
                ReplicatedStorage.BuyItemRemote:FireServer(ToolName, "Remove", ToolId)
            end)
        end

        task.spawn(function()
            ReplicatedStorage.BackpackRemote:InvokeServer("Grab", ToolName)
        end)

        marketconnection:Disconnect()
        task.wait(1)
    end
})

DupeSection:Button({
    Name = "Money Dupe",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:WaitForChild("Humanoid")
        local hrp = character:WaitForChild("HumanoidRootPart")
        local originalPos = hrp.Position

        local function teleportTo(x, y, z)
            humanoid:ChangeState(0)
            -- Safely wait if attribute exists, else skip
            if player:GetAttribute("LastACPos") ~= nil then
                repeat task.wait() until not player:GetAttribute("LastACPos")
            end
            hrp.CFrame = CFrame.new(x, y, z)
            humanoid.PlatformStand = false
            hrp.Velocity = Vector3.new(0, 0, 0)
            hrp.RotVelocity = Vector3.new(0, 0, 0)
        end

        local sellPart = workspace:FindFirstChild("IceFruit Sell")
        local sellPrompt = sellPart and sellPart:FindFirstChildWhichIsA("ProximityPrompt")

        if not sellPrompt then
            warn("ProximityPrompt not found on sell part.")
            return
        end

        task.wait(0.5)
        teleportTo(-48, 287, -338)
        task.wait(1)

        local success, err = pcall(function()
            for _ = 1, 1200 do
                fireproximityprompt(sellPrompt, 0)
            end
        end)

        if not success then
            warn("Proximity prompt interaction failed:", err)
        end

        task.wait(1)
        teleportTo(originalPos.X, originalPos.Y, originalPos.Z)
    end
})

local SharedStorage = game.ReplicatedStorage

local function InvokeServer(Remote, ...)
    return Remote:InvokeServer(...)
end

local function FindItem(Item)
    return game.Players.LocalPlayer.Backpack:FindFirstChild(Item) or
    game.Players.LocalPlayer.Character:FindFirstChild(Item)
end

local function AutoBuySupplies()
    local Items = {
        "Ice-Fruit Bag",
        "Ice-Fruit Cupz",
        "FijiWater",
        "FreshWater",
    }

    for _, item in ipairs(Items) do
        local ItemStock = SharedStorage.ExoticStock:FindFirstChild(item)
        if not ItemStock or ItemStock.Value == 0 then
            warn("Item out of stock:", item)
            return false
        end
    end

    for _, item in ipairs(Items) do
        InvokeServer(SharedStorage.ExoticShopRemote, item)
        task.wait(1.25)
    end

    for _, item in ipairs(Items) do
        if not FindItem(item) then
            warn("Failed to acquire:", item)
            return false
        end
    end

    return true
end

DupeSection:Button({
    Name = "Purchase Ice-Fruitz",
    Callback = function()
        AutoBuySupplies()
    end
})

local BankSection = Tab:Section({Name = "ATM/BANK", Side = "Right"})

local bankAmount = "0"
local autoDropEnabled = false

BankSection:Textbox({
    Name = "Amount (Cash) - Max: 10,000",
    Default = "0",
    Placeholder = "(<ENTER_$_AMOUNT>",
    Callback = function(value)
        bankAmount = tostring(value)
    end
})

BankSection:Button({
    Name = "Withdraw Amount",
    Callback = function()
        local args = {
            "with",
            bankAmount
        }
        game:GetService("ReplicatedStorage"):WaitForChild("BankAction"):FireServer(unpack(args))
    end
})

BankSection:Button({
    Name = "Deposit Amount",
    Callback = function()
        local args = {
            "depo",
            bankAmount
        }
        game:GetService("ReplicatedStorage"):WaitForChild("BankProcessRemote"):InvokeServer(unpack(args))
    end
})

BankSection:Button({
    Name = "Drop Amount",
    Callback = function()
        local args = {
            "Drop",
            bankAmount
        }
        game:GetService("ReplicatedStorage"):WaitForChild("BankProcessRemote"):InvokeServer(unpack(args))
    end
})

BankSection:Toggle({
    Name = "Automatic Drop Cash",
    CurrentValue = false,
    Callback = function(state)
        autoDropEnabled = state
        if state then
            task.spawn(function()
                while autoDropEnabled do
                    local args = {
                        "Drop",
                        bankAmount
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("BankProcessRemote"):InvokeServer(unpack(args))
                    task.wait(1.5)
                end
            end)
        end
    end
})

local ShopSection = Tab:Section({Name = "Quick Shop", Side = "Right"})

ShopSection:Button({
    Name = "Purchase Water ($10)",
    Callback = function()
        local args = {"Water"}
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("ShopRemote"):InvokeServer(unpack(args))
        end)
    end
})

ShopSection:Button({
    Name = "Purchase Shiesty ($25)",
    Callback = function()
        local args = {"Shiesty"}
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("ShopRemote"):InvokeServer(unpack(args))
        end)
    end
})

ShopSection:Button({
    Name = "Purchase Gloves ($10)",
    Callback = function()
        local args = {"BlackGloves"} -- fixed argument here
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("ShopRemote"):InvokeServer(unpack(args))
        end)
    end
})

ShopSection:Divider({Text = "Exotic Dealer",Side = "Right"})

ShopSection:Button({
    Name = "Purchase FakeCard ($700)",
    Callback = function()
        local args = {"FakeCard"} 
        pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("ExoticShopRemote"):InvokeServer(unpack(args))
        end)
    end
})

ShopSection:Divider({Text = "Manual Purchasing",Side = "Right"})

local selectedItems = {}

local itemsList = {
    "RawChicken",
    "PinkCamo Gloves",
    "RedGloves",
    "BluCamo Gloves",
    "BluShiestyCam",
    "PurpleCamoGloves",
    "Yello Camo Gloves",
    "Shiesty",
    "Water",
    "BluGloves",
    "White Gloves",
    "BlackGloves",
    "RawSteak",
    "YelloShiesty",
    "WhiteShiesty",
    "RedCamo Gloves",
}

local Dropdown = ShopSection:Dropdown({
    Name = "Select item / Weapon",
    List = (function()
        local list = {}
        for _, itemName in ipairs(itemsList) do
            table.insert(list, {
                Name = itemName,
                Mode = "Toggle", -- allow multi-selection
                Value = false,
                Callback = function(selected)
                    -- selected is a table of selected items, update selectedItems
                    selectedItems = selected
                end,
            })
        end
        return list
    end)(),
})

local BuyButton = ShopSection:Button({
    Name = "Purchase Selected Item",
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local shopRemote = ReplicatedStorage:WaitForChild("ShopRemote")

        for _, itemName in ipairs(selectedItems) do
            local success, err = pcall(function()
                shopRemote:InvokeServer(itemName)
            end)
            if not success then
                warn("Failed to buy item:", itemName, err)
            end
        end
    end,
})



local TSection = Tab:Section({Name = "Teleports", Side = "Right"})

local teleportLocations = {
    { Name = "👕Dripstore",       Position = Vector3.new(67459, 10489, 551) },
    { Name = "🏦Bank",               Position = Vector3.new(-204, 284, -1223) },
    { Name = "💎Ice Box",            Position = Vector3.new(-193, 284, -1169) },
    { Name = "💰Bank tools / Roof",  Position = Vector3.new(-384, 340, -557) },
    { Name = "🍕Jamaican Food",      Position = Vector3.new(-670, 254, -810) },
    { Name = "🥘Deli and Grill",     Position = Vector3.new(-746, 254, -906) },
    { Name = "🍗Chicken and Wings",  Position = Vector3.new(964, 254, -813) },
    { Name = "🔫Gunstore [1]",       Position = Vector3.new(-1003, 254, -817) },
    { Name = "🔫Gunstore [2]",       Position = Vector3.new(-202, 284, -798) },
    { Name = "🔫Gunstore [3]",       Position = Vector3.new(72425, 128856, -1082) },
    { Name = "🔫Gunstore [4]",       Position = Vector3.new(60822, 87609, -352) },
    { Name = "🛍️Pawnshop",           Position = Vector3.new(-1051, 254, -815) },
    { Name = "🧺Laundermat",         Position = Vector3.new(-990, 254, -686) },
    { Name = "🎒Backpack",           Position = Vector3.new(-670, 254, -681) },
    { Name = "✍️Tatoo",              Position = Vector3.new(-637, 254, -591) },
    { Name = "🍯Penthouse Cook Pot", Position = Vector3.new(-614, 356, -683) },
    { Name = "🏠New Penthouse",      Position = Vector3.new(-597, 356, -714) },
    { Name = "🏡Old Penthouse",      Position = Vector3.new(-124, 417, -575) },
    { Name = "💲Dollar Central",     Position = Vector3.new(-389, 254, -1082) },
    { Name = "🚗Dealership",         Position = Vector3.new(-389, 253, -1232) },
    { Name = "🍔mcdonalds",          Position = Vector3.new(-999, 254, -1134) },
}

local player = game.Players.LocalPlayer

local function teleport(x, y, z)
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    local hrp = character:WaitForChild("HumanoidRootPart")

    humanoid:ChangeState(0)
    if player:GetAttribute("LastACPos") ~= nil then
        repeat task.wait() until not player:GetAttribute("LastACPos")
    end
    hrp.CFrame = CFrame.new(x, y, z)
end

local selectedTeleport = teleportLocations[1]

TSection:Dropdown({
    Name = "Teleports",
    Mode = "Toggle",
    Side = "Left",
    List = (function()
        local list = {}
        for _, location in ipairs(teleportLocations) do
            table.insert(list, {
                Name = location.Name,
                Mode = "Button",
                Callback = function()
                    selectedTeleport = location
                end
            })
        end
        return list
    end)()
})

TSection:Button({
    Name = "Teleport to Selected Location",
    Side = "Left",
    Callback = function()
        if selectedTeleport then
            teleport(selectedTeleport.Position.X, selectedTeleport.Position.Y, selectedTeleport.Position.Z)
        end
    end
})

local Tab = Window:Tab({Name = "Combat"})
local XSection = Tab:Section({Name = "Hitbox", Side = "Left"})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

_G.HeadSize = 50
_G.Disabled = true 
_G.Shape = "Box" 
_G.Material = Enum.Material.Neon

local originalProperties = {}

local function resetHitbox(player)
    pcall(function()
        local character = player.Character
        if character then
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp and originalProperties[player.UserId] then
                local props = originalProperties[player.UserId]
                hrp.Size = props.Size
                hrp.Transparency = props.Transparency
                hrp.BrickColor = props.BrickColor
                hrp.Material = props.Material
                hrp.CanCollide = props.CanCollide
                hrp.Shape = props.Shape or Enum.PartType.Block
            end
        end
    end)
end

RunService.RenderStepped:Connect(function()
    if not _G.Disabled then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                pcall(function()
                    local character = player.Character
                    if character then
                        local hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            if not originalProperties[player.UserId] then
                                originalProperties[player.UserId] = {
                                    Size = hrp.Size,
                                    Transparency = hrp.Transparency,
                                    BrickColor = hrp.BrickColor,
                                    Material = hrp.Material,
                                    CanCollide = hrp.CanCollide,
                                    Shape = hrp.Shape,
                                }
                            end
                            hrp.Size = Vector3.new(_G.HeadSize, _G.HeadSize, _G.HeadSize)
                            hrp.Transparency = 0.7
                            hrp.BrickColor = BrickColor.new("Really blue")
                            hrp.Material = _G.Material
                            hrp.CanCollide = false
                            hrp.Shape = (_G.Shape == "Sphere") and Enum.PartType.Ball or Enum.PartType.Block
                        end
                    end
                end)
            end
        end
    else
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                resetHitbox(player)
            end
        end
    end
end)

XSection:Toggle({
    Name = "Hitbox Expander",
    CurrentValue = not _G.Disabled,
    Callback = function(value)
        _G.Disabled = not value
    end
})

XSection:Dropdown({
    Name = "Hitbox Type",
    List = {
        {
            Name = "Box",
            Mode = "Button",
            Callback = function()
                _G.Shape = "Box"
            end
        },
        {
            Name = "Sphere",
            Mode = "Button",
            Callback = function()
                _G.Shape = "Sphere"
            end
        }
    }
})

XSection:Dropdown({
    Name = "Hitbox Material",
    List = {
        { Name = "Neon", Mode = "Button", Callback = function() _G.Material = Enum.Material.Neon end },
        { Name = "Plastic", Mode = "Button", Callback = function() _G.Material = Enum.Material.Plastic end },
        { Name = "SmoothPlastic", Mode = "Button", Callback = function() _G.Material = Enum.Material.SmoothPlastic end },
        { Name = "ForceField", Mode = "Button", Callback = function() _G.Material = Enum.Material.ForceField end },
        { Name = "Glass", Mode = "Button", Callback = function() _G.Material = Enum.Material.Glass end },
        { Name = "Metal", Mode = "Button", Callback = function() _G.Material = Enum.Material.Metal end },
        { Name = "Wood", Mode = "Button", Callback = function() _G.Material = Enum.Material.Wood end },
        { Name = "Granite", Mode = "Button", Callback = function() _G.Material = Enum.Material.Granite end }
    }
})

XSection:Slider({
    Name = "Hitbox Multiplier",
    Min = 5,
    Max = 100,
    Value = _G.HeadSize,
    Callback = function(value)
        _G.HeadSize = value
    end
})

local GSection = Tab:Section({Name = "Weapon Modifications", Side = "Left"})

GSection:Toggle({
	Name = "Instant Equip",
	CurrentValue = false,
	Callback = function(Value)
		local tool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
		if tool and tool:FindFirstChild("Setting") then
			require(tool.Setting).EquippedAnimationSpeed = Value and 0 or 1
		end
	end
})

GSection:Toggle({
	Name = "Instant Reload",
	CurrentValue = false,
	Callback = function(Value)
		local tool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
		if tool and tool:FindFirstChild("Setting") then
			require(tool.Setting).ReloadTime = Value and 0 or 1.5
		end
	end
})

GSection:Toggle({
	Name = "No Jam",
	CurrentValue = false,
	Callback = function(Value)
		local tool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
		if tool and tool:FindFirstChild("Setting") then
			require(tool.Setting).JamChance = Value and 0 or 1
		end
	end
})

GSection:Toggle({
	Name = "No Recoil",
	CurrentValue = false,
	Callback = function(Value)
		local tool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
		if tool and tool:FindFirstChild("Settings") then
			require(tool.Settings).Recoil = Value and 0 or 1
		end
	end
})

GSection:Toggle({
	Name = "No Spread",
	CurrentValue = false,
	Callback = function(Value)
		local tool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
		if tool and tool:FindFirstChild("Settings") then
			require(tool.Settings).Recoil = Value and 0 or 1
		end
	end
})

GSection:Toggle({
	Name = "Full Auto",
	CurrentValue = false,
	Callback = function(Value)
		local tool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
		if tool and tool:FindFirstChild("Setting") then
			require(tool.Setting).Auto = Value and 9e9 or 1
		end
	end
})

GSection:Toggle({
	Name = "Infinite Ammo",
	CurrentValue = false,
	Callback = function(Value)
		local tool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
		if tool and tool:FindFirstChild("Setting") then
			require(tool.Setting).AmmoPerMag = Value and 1e9 or 30
		end
	end
})

GSection:Toggle({
	Name = "Infinite Range",
	CurrentValue = false,
	Callback = function(Value)
		local tool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
		if tool and tool:FindFirstChild("Setting") then
			require(tool.Setting).Range = Value and 9e9 or 100
		end
	end
})

GSection:Toggle({
	Name = "Life Steal",
	CurrentValue = false,
	Callback = function(Value)
		local tool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
		if tool and tool:FindFirstChild("Setting") then
			local setting = require(tool.Setting)
			setting.LimitedAmmoEnabled = not Value
			setting.MaxAmmo = Value and 1e8 or 100
			setting.AmmoPerMag = Value and 1e7 or 30
			setting.Ammo = Value and 1e8 or 100
		end
	end
})

GSection:Toggle({
	Name = "1 Tap",
	CurrentValue = false,
	Callback = function(Value)
		local tool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
		if tool and tool:FindFirstChild("Setting") then
			require(tool.Setting).BaseDamage = Value and 9e9 or 10
		end
	end
})

GSection:Toggle({
	Name = "Sniper Mode",
	CurrentValue = false,
	Callback = function(Value)
		local tool = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
		if tool and tool:FindFirstChild("Setting") then
			require(tool.Setting).SniperEnabled = Value
		end
	end
})

local SSection = Tab:Section({Name = "Silent", Side = "Right"})

SSection:Toggle({
    Name = "Enabled",
    Value = false,
    Callback = function()
        print("h")
    end
})

SSection:Toggle({
    Name = "Wall Bang",
    Value = false,
    Callback = function()
        print("gay")
    end
})

local bodyPartsList = {
    "Head", "HumanoidRootPart", "Torso", "LeftArm", "RightArm", 
    "LeftLeg", "RightLeg", "LeftFoot", "RightFoot", "Neck", "LeftHand", "RightHand"
}

local selectedBodyPart = "Head"

local options = {}
for _, partName in ipairs(bodyPartsList) do
    table.insert(options, {
        Name = partName,
        Mode = "Toggle",
        Value = (partName == selectedBodyPart),
        Callback = function(selected)
            if selected then
                selectedBodyPart = partName
                -- Update all options so only this one is selected
                for _, option in pairs(options) do
                    option.Value = (option.Name == selectedBodyPart)
                end
                print("Selected body part:", selectedBodyPart)
            end
        end
    })
end

local Dropdown = SSection:Dropdown({
    Name = "Target Part",
    Side = "Right",
    Default = selectedBodyPart,
    List = options
})

local priorityOptions = {
    "High",
    "Medium",
    "Low",
    "None"
}

local selectedPriority = "Medium" -- default

local priorityDropdownOptions = {}
for _, priority in ipairs(priorityOptions) do
    table.insert(priorityDropdownOptions, {
        Name = priority,
        Mode = "Toggle",
        Value = (priority == selectedPriority),
        Callback = function(selected)
            if selected then
                selectedPriority = priority
                for _, option in pairs(priorityDropdownOptions) do
                    option.Value = (option.Name == selectedPriority)
                end
                print("Selected priority:", selectedPriority)
            end
        end
    })
end

local PriorityDropdown = SSection:Dropdown({
    Name = "Priority List",
    Side = "Left",
    Default = selectedPriority,
    List = priorityDropdownOptions
})

local Players = game:GetService("Players")
local selectedPlayerName = Players.LocalPlayer.Name

local function getPlayerDropdownOptions()
    local options = {}
    for _, player in ipairs(Players:GetPlayers()) do
        table.insert(options, {
            Name = player.Name,
            Mode = "Toggle",
            Value = (player.Name == selectedPlayerName),
            Callback = function(selected)
                if selected then
                    selectedPlayerName = player.Name
                    for _, option in pairs(options) do
                        option.Value = (option.Name == selectedPlayerName)
                    end
                    print("Selected player:", selectedPlayerName)
                end
            end
        })
    end
    return options
end

local playerDropdownOptions = getPlayerDropdownOptions()

local PlayerDropdown = SSection:Dropdown({
    Name = "White List",
    Side = "Left",
    Default = selectedPlayerName,
    List = playerDropdownOptions
})

Players.PlayerAdded:Connect(function()
    playerDropdownOptions = getPlayerDropdownOptions()
    PlayerDropdown:Clear()
    for _, option in pairs(playerDropdownOptions) do
        PlayerDropdown:AddOption(option)
    end
end)

Players.PlayerRemoving:Connect(function()
    playerDropdownOptions = getPlayerDropdownOptions()
    PlayerDropdown:Clear()
    for _, option in pairs(playerDropdownOptions) do
        PlayerDropdown:AddOption(option)
    end
end)

SSection:Divider({Text = "Silent Settings",Side = "Right"})

local sides = 0
local radius = 100
local enabled = false

local fovCircle = Drawing.new("Circle")
fovCircle.Color = Color3.fromRGB(255, 255, 255)
fovCircle.Thickness = 2
fovCircle.NumSides = 300
fovCircle.Transparency = 1
fovCircle.Visible = false
fovCircle.Filled = false
fovCircle.Radius = radius

local lines = {}

local function createLines(num)
    for _, line in pairs(lines) do
        line:Remove()
    end
    lines = {}
    for i = 1, num do
        local line = Drawing.new("Line")
        line.Color = Color3.fromRGB(255, 255, 255)
        line.Thickness = 2
        line.Transparency = 1
        line.Visible = false
        table.insert(lines, line)
    end
end

createLines(sides > 0 and sides or 0)

local function updatePolygon(position, radius, sides)
    for i = 1, sides do
        local angle1 = (2 * math.pi / sides) * (i - 1) - math.pi / 2
        local angle2 = (2 * math.pi / sides) * (i % sides) - math.pi / 2

        local p1 = Vector2.new(position.X + radius * math.cos(angle1), position.Y + radius * math.sin(angle1))
        local p2 = Vector2.new(position.X + radius * math.cos(angle2), position.Y + radius * math.sin(angle2))

        lines[i].From = p1
        lines[i].To = p2
        lines[i].Visible = enabled
    end
end

local function hidePolygon()
    for _, line in pairs(lines) do
        line.Visible = false
    end
end

SSection:Toggle({
    Name = "Enabled",
    Value = enabled,
    Callback = function(val)
        enabled = val
        if enabled then
            if sides == 0 then
                fovCircle.Visible = true
                hidePolygon()
            else
                fovCircle.Visible = false
                for _, line in pairs(lines) do
                    line.Visible = true
                end
            end
        else
            fovCircle.Visible = false
            hidePolygon()
        end
    end,
})



SSection:Slider({
    Name = "Radius",
    Min = 10,
    Max = 300,
    Increment = 1,
    Value = radius,
    Callback = function(val)
        radius = val
        fovCircle.Radius = radius
    end,
})

SSection:Slider({
    Name = "Sides",
    Min = 0,
    Max = 100,
    Increment = 1,
    Value = sides,
    Callback = function(val)
        sides = val
        if sides == 0 then
            fovCircle.Visible = enabled
            hidePolygon()
        elseif sides >= 3 then
            fovCircle.Visible = false
            createLines(sides)
            if enabled then
                for _, line in pairs(lines) do
                    line.Visible = true
                end
            end
        else
            sides = 0
            fovCircle.Visible = enabled
            hidePolygon()
        end
    end,
})

game:GetService("RunService").RenderStepped:Connect(function()
    if enabled then
        local mouse = game.Players.LocalPlayer:GetMouse()
        local pos = Vector2.new(mouse.X, mouse.Y)
        if sides == 0 then
            fovCircle.Position = pos
            fovCircle.Radius = radius
            fovCircle.Visible = true
            hidePolygon()
        else
            updatePolygon(pos, radius, sides)
            fovCircle.Visible = false
        end
    else
        fovCircle.Visible = false
        hidePolygon()
    end
end)

SSection:Divider({Text = "Misc",Side = "Right"})

getgenv().auraenabled = false
getgenv().visualizeAura = false
getgenv().damage = 9e9
getgenv().hitpart = "Head"
getgenv().beam = true
getgenv().color = Color3.fromRGB(0, 255, 0) -- fixed green beam color
getgenv().killauraSize = 30

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Visualization sphere
local auraSphere
local function createAuraSphere()
    if auraSphere then auraSphere:Destroy() end
    auraSphere = Instance.new("Part")
    auraSphere.Shape = Enum.PartType.Ball
    auraSphere.Transparency = 0.7
    auraSphere.Anchored = true
    auraSphere.CanCollide = false
    auraSphere.Material = Enum.Material.Neon
    auraSphere.Color = getgenv().color
    auraSphere.Parent = workspace
    auraSphere.Size = Vector3.new(getgenv().killauraSize * 2, getgenv().killauraSize * 2, getgenv().killauraSize * 2)
end

RunService.Heartbeat:Connect(function()
    if getgenv().visualizeAura and auraSphere and Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        auraSphere.Position = Players.LocalPlayer.Character.HumanoidRootPart.Position
        auraSphere.Size = Vector3.new(getgenv().killauraSize * 2, getgenv().killauraSize * 2, getgenv().killauraSize * 2)
    elseif auraSphere then
        auraSphere:Destroy()
        auraSphere = nil
    end
end)

local function GetNearestPlayer()
    local localPlayer = Players.LocalPlayer
    local nearestPlayer = nil
    local nearestDistance = math.huge
    if not (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) then return nil end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local dist = (localPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
            if dist < nearestDistance and dist <= getgenv().killauraSize then
                nearestDistance = dist
                nearestPlayer = player
            end
        end
    end

    return nearestPlayer
end

local function dmg(target, hitpart, damage)
    if target and target.Character and target.Character:FindFirstChild(hitpart) then
        local humanoid = target.Character:FindFirstChildOfClass("Humanoid")
        if humanoid and humanoid.Health > 0 then
            humanoid:TakeDamage(damage)
        end
    end
end


SSection:Toggle({
    Name = "Kill Aura",
    Side = "Left",
    Value = false,
    Callback = function(val)
        getgenv().auraenabled = val
        if val then
            task.spawn(function()
                while getgenv().auraenabled do
                    task.wait(0.1)
                    local target = GetNearestPlayer()
                    if target and target.Character and target.Character:FindFirstChild(getgenv().hitpart) then
                        if getgenv().beam then
                            pcall(function()
                                if Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildWhichIsA("Tool") then
                                    local plr = Players.LocalPlayer
                                    local part = Instance.new("Part", workspace)
                                    local dist = (plr.Character.HumanoidRootPart.Position - target.Character[getgenv().hitpart].Position).Magnitude
                                    part.Size = Vector3.new(0.2, 0.2, dist)
                                    part.Anchored = true
                                    part.CanCollide = false
                                    part.Material = Enum.Material.Neon
                                    part.Color = getgenv().color
                                    local toolHandle = plr.Character:FindFirstChildWhichIsA("Tool"):FindFirstChild("Handle")
                                    if toolHandle then
                                        local midpoint = (toolHandle.Position + target.Character[getgenv().hitpart].Position) / 2
                                        part.Position = midpoint
                                        part.CFrame = CFrame.new(midpoint, target.Character[getgenv().hitpart].Position)
                                    end
                                    task.wait(0.1)
                                    part:Destroy()
                                end
                            end)
                        end
                        dmg(target, getgenv().hitpart, getgenv().damage)
                    end
                end
            end)
        end
    end
})


SSection:Toggle({
    Name = "Visualize Kill Aura",
    Side = "Left",
    Value = false,
    Callback = function(val)
        getgenv().visualizeAura = val
        if val then
            createAuraSphere()
        elseif auraSphere then
            auraSphere:Destroy()
            auraSphere = nil
        end
    end
})


SSection:Slider({
    Name = "Kill Aura Size",
    Side = "Left",
    Min = 5,
    Max = 100,
    Value = getgenv().killauraSize,
    Precise = 0,
    Unit = " studs",
    Callback = function(val)
        getgenv().killauraSize = val
        if auraSphere then
            auraSphere.Size = Vector3.new(val * 2, val * 2, val * 2)
        end
    end
})

local Tab = Window:Tab({Name = "Farms"})
local FSection = Tab:Section({Name = "Autofarms", Side = "Left"})

FSection:Divider({Text = "Jobs",Side = "Left"})

local player = game.Players.LocalPlayer

function teleport(x, y, z)
    local char = player.Character or player.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local root = char:WaitForChild("HumanoidRootPart")

    humanoid:ChangeState(0)
    repeat task.wait() until not player:GetAttribute("LastACPos")
    root.CFrame = CFrame.new(x, y, z)
end

FSection:Toggle({
    Name = "Search Trashbags",
    Side = "Left",
    Value = false,
    Callback = function(Value)
        getgenv().loottrash = Value
        if Value then
            for _, v in pairs(workspace:GetDescendants()) do
                if v:IsA("ProximityPrompt") and v.Name == "ProximityPrompt" and v.Parent.Name == "DumpsterPromt" then
                    v.HoldDuration = 0
                    v.RequiresLineOfSight = false
                end
            end

            task.spawn(function()
                while getgenv().loottrash do
                    task.wait()
                    for _, v in pairs(workspace:GetDescendants()) do
                        if v:IsA("ProximityPrompt") and v.Name == "ProximityPrompt" and v.Parent.Name == "DumpsterPromt" then
                            local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                teleport(v.Parent.Position.X, v.Parent.Position.Y, v.Parent.Position.Z + 3)
                            end
                            workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position,
                                v.Parent.Position)
                            task.wait(0.3)
                            for _ = 1, 10 do fireproximityprompt(v) end
                            task.wait(0.1)
                            if not getgenv().loottrash then break end
                        end
                    end
                end
            end)
        end
    end
})

local player = game.Players.LocalPlayer
local selling = false

FSection:Toggle({
    Name = "Auto Sell Pawned Items",
    Side = "Left",
    Value = false,
    Callback = function(Value)
        selling = Value
        if selling then
            task.spawn(function()
                while selling do
                    for _, frame in ipairs(player.PlayerGui["Bronx PAWNING"].Frame.Holder.List:GetChildren()) do
                        if frame:IsA("Frame") then
                            local itemName = frame.Item.Text
                            while player.Backpack:FindFirstChild(itemName) and selling do
                                game.ReplicatedStorage.PawnRemote:FireServer(itemName)
                                task.wait(0.1)
                            end
                        end
                    end
                    task.wait(0.1) -- small wait to avoid overloading
                end
            end)
        end
    end
})

FSection:Button({
    Name = "Sell Pawned items",
    Side = "Left",
    Callback = function(Value)
        task.spawn(function()
            for _, frame in ipairs(player.PlayerGui["Bronx PAWNING"].Frame.Holder.List:GetChildren()) do
                if frame:IsA("Frame") then
                    local itemName = frame.Item.Text
                    while player.Backpack:FindFirstChild(itemName) do
                        game.ReplicatedStorage.PawnRemote:FireServer(itemName)
                        task.wait(0.05)
                    end
                end
            end
        end)
    end
})       

local autofarmRunning = false
local Players = game:GetService("Players")
local speaker = Players.LocalPlayer

local function getCharacter()
    return speaker.Character or speaker.CharacterAdded:Wait()
end

local function safeTeleport(cf)
    local character = getCharacter()
    local humanoid = character:WaitForChild("Humanoid")
    local hrp = character:WaitForChild("HumanoidRootPart")
    humanoid:ChangeState(0)
    repeat task.wait() until not speaker:GetAttribute("LastACPos")
    hrp.CFrame = cf
end

local function fireProximityPrompt(prompt)
    if prompt and prompt:IsA("ProximityPrompt") then
        fireproximityprompt(prompt)
    end
end

local function startConstructionJob()
    safeTeleport(CFrame.new(-1728, 371, -1172))
    task.wait(0.2)
    fireProximityPrompt(workspace.ConstructionStuff["Start Job"]:FindFirstChildOfClass("ProximityPrompt"))
    task.wait(0.5)
end

local function getBackpack()
    return speaker:FindFirstChild("Backpack")
end

local function hasPlyWood()
    local backpack = getBackpack()
    local character = getCharacter()
    return (backpack and backpack:FindFirstChild("PlyWood")) or
           (character and character:FindFirstChild("PlyWood"))
end

local function equipPlyWood()
    local backpack = getBackpack()
    if backpack then
        local plyWood = backpack:FindFirstChild("PlyWood")
        if plyWood then
            plyWood.Parent = getCharacter()
        end
    end
end

local function grabWood()
    safeTeleport(CFrame.new(-1727, 371, -1178))
    task.wait(0.1)

    while autofarmRunning and not hasPlyWood() do
        fireProximityPrompt(workspace.ConstructionStuff["Grab Wood"]:FindFirstChildOfClass("ProximityPrompt"))
        task.wait(0.1)
        equipPlyWood()
    end
end

local function buildWall(wallPromptName, wallPosition)
    local prompt = workspace.ConstructionStuff[wallPromptName]:FindFirstChildOfClass("ProximityPrompt")

    while autofarmRunning and prompt and prompt.Enabled do
        safeTeleport(wallPosition)
        task.wait(0.01)
        fireProximityPrompt(prompt)
        task.wait()
        if not hasPlyWood() then
            grabWood()
        end
    end
end

FSection:Toggle({
    Name = "Construction Job",
    Side = "Left",
    Value = false,
    Callback = function(Value)
        autofarmRunning = Value
        if not speaker then return end

        if autofarmRunning then
            task.spawn(function()
                startConstructionJob() -- auto start job on toggle on
                
                while autofarmRunning do
                    if not hasPlyWood() then
                        grabWood()
                    end

                    buildWall("Wall2 Prompt", CFrame.new(-1705, 368, -1151))
                    buildWall("Wall3 Prompt", CFrame.new(-1732, 368, -1152))
                    buildWall("Wall4 Prompt2", CFrame.new(-1772, 368, -1152))
                    buildWall("Wall1 Prompt3", CFrame.new(-1674, 368, -1166))

                    task.wait(0.1)
                end
            end)
        end
    end
})

FSection:Divider({Text = "Robberies",Side = "Left"})

local camera = workspace.CurrentCamera

function stuidoprompt()
    for _, v in pairs(workspace.StudioPay.Money:GetDescendants()) do
        if v:IsA("ProximityPrompt") and v.Name == "Prompt" then
            v.HoldDuration = 0
            v.RequiresLineOfSight = false
        end
    end
end

FSection:Toggle({
    Name = "Rob 'On The Radar' Studio",
    Side = "Left",
    Value = false,
    Callback = function(Value)
        local robstudio = Value

        if robstudio then
            local player = game.Players.LocalPlayer
            local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
            if not root or not humanoid then return end

            local originalCFrame = root.CFrame
            stuidoprompt()

            for _, v in pairs(workspace.StudioPay.Money:GetDescendants()) do
                if v:IsA("ProximityPrompt") and v.Name == "Prompt" and v.Enabled then
                    humanoid:ChangeState(0)
                    repeat task.wait() until not player:GetAttribute("LastACPos")

                    root.CFrame = CFrame.new(
                        v.Parent.Position.X,
                        v.Parent.Position.Y + 2,
                        v.Parent.Position.Z
                    )

                    camera.CFrame = CFrame.new(camera.CFrame.Position, v.Parent.Position)
                    task.wait(0.25)

                    repeat
                        task.wait(0.3)
                        fireproximityprompt(v)
                    until v.Enabled == false or not robstudio

                    if not robstudio then break end
                end
            end

            if robstudio then
                root.CFrame = originalCFrame
            end
        end
    end
})


local Players = game:GetService("Players")
local player = Players.LocalPlayer
local Camera = workspace.CurrentCamera

function BypassTp(cf)
    local char = player.Character or player.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local root = char:WaitForChild("HumanoidRootPart")

    humanoid:ChangeState(0)
    repeat task.wait() until not player:GetAttribute("LastACPos")
    root.CFrame = cf
end

local Houseleft = {}
local Houseright = {}

local targetPosition = Vector3.new(-615, 254, -695)

function updateDoors()
    table.clear(Houseleft)
    table.clear(Houseright)

    for _, v in pairs(workspace.HouseRobb:GetDescendants()) do
        if (v.Name == "WoodenDoor" or v.Name == "HardDoor") and v:IsA("BasePart") and v:FindFirstChild("ProximityPrompt") then
            if (v.Position - targetPosition).Magnitude <= 10 then
                Houseright[v.Name] = v
            else
                Houseleft[v.Name] = v
            end
        end
    end
end

function HouseRobPrompts()
    for _, v in pairs(workspace.HouseRobb:GetDescendants()) do
        if v:IsA("ProximityPrompt") and v.Name == "ProximityPrompt" then
            v.HoldDuration = 0
            v.RequiresLineOfSight = false
            v.Enabled = false
        end
    end
end


FSection:Toggle({
    Name = "Rob Houses",
    Side = "Left",
    Value = false,
    Callback = function(Value)
        RobHouse = Value
        local OldCframe = player.Character.HumanoidRootPart.CFrame

        if RobHouse then
            HouseRobPrompts()
        end

        task.spawn(function()
            while RobHouse do
                task.wait()
                updateDoors()

                if not RobHouse then break end

                local house1Robbed = Houseleft["HardDoor"] and Houseleft["HardDoor"].Transparency == 1
                local moneyParts = Houseleft["HardDoor"] and
                Houseleft["HardDoor"].Parent.Parent:FindFirstChild("TakeMoney")
                local moneyFound = false

                if house1Robbed and moneyParts then
                    for _, part in pairs(moneyParts:GetChildren()) do
                        if part.Name == "MoneyGrab" and part.Transparency == 0 then
                            moneyFound = true
                            break
                        end
                    end
                end

                if not house1Robbed then
                    for _, v in pairs(Houseleft["HardDoor"]:GetDescendants()) do
                        if v:IsA("ProximityPrompt") and v.Name == "ProximityPrompt" then
                            v.Enabled = true
                            BypassTp(v.Parent.CFrame * CFrame.new(-1.5, 0, 0))
                            Camera.CFrame = CFrame.new(Camera.CFrame.Position, v.Parent.Position)
                            repeat
                                task.wait()
                                fireproximityprompt(v)
                            until Houseleft["HardDoor"].Transparency == 1
                        end
                    end

                    for _, v in pairs(Houseleft["HardDoor"].Parent.Parent:GetDescendants()) do
                        if v:IsA("ProximityPrompt") and v.Name == "ProximityPrompt" then
                            HouseRobPrompts()
                            local targetCFrame = v.Parent.CFrame * CFrame.new(0, 0, -3)
                            BypassTp(targetCFrame)
                            Camera.CFrame = CFrame.new(Camera.CFrame.Position, v.Parent.Position)
                            v.Enabled = true
                            repeat
                                fireproximityprompt(v)
                                task.wait()
                            until v.Parent.Transparency == 1
                            v.Enabled = false
                        end
                    end
                end

                local house2Robbed = Houseright["WoodenDoor"] and Houseright["WoodenDoor"].Transparency == 1
                local moneyParts2 = Houseright["WoodenDoor"] and
                Houseright["WoodenDoor"].Parent.Parent:FindFirstChild("TakeMoney")
                local moneyFound2 = false

                if house2Robbed and moneyParts2 then
                    for _, part in pairs(moneyParts2:GetChildren()) do
                        if part.Name == "MoneyGrab" and part.Transparency == 0 then
                            moneyFound2 = true
                            break
                        end
                    end
                end

                if not house2Robbed then
                    for _, v in pairs(Houseright["WoodenDoor"]:GetDescendants()) do
                        if v:IsA("ProximityPrompt") and v.Name == "ProximityPrompt" then
                            v.Enabled = true
                            BypassTp(v.Parent.CFrame * CFrame.new(-1.5, 0, 0))
                            Camera.CFrame = CFrame.new(Camera.CFrame.Position, v.Parent.Position)
                            repeat
                                task.wait()
                                fireproximityprompt(v)
                            until Houseright["WoodenDoor"].Transparency == 1
                        end
                    end

                    for _, v in pairs(Houseright["WoodenDoor"].Parent.Parent:GetDescendants()) do
                        if v:IsA("ProximityPrompt") and v.Name == "ProximityPrompt" then
                            HouseRobPrompts()
                            local targetCFrame = v.Parent.CFrame * CFrame.new(0, 0, -3)
                            BypassTp(targetCFrame)
                            Camera.CFrame = CFrame.new(Camera.CFrame.Position, v.Parent.Position)
                            v.Enabled = true
                            repeat
                                fireproximityprompt(v)
                                task.wait()
                            until v.Parent.Transparency == 1
                            v.Enabled = false
                        end
                    end
                end

                BypassTp(OldCframe)
                break
            end
        end)
    end
})

FSection:Toggle({
    Name = "Rob Bank",
    Side = "Left",
    Value = false,
    Callback = function(Value)
        print("N")
        end
    })

FSection:Divider({Text = "Pickups",Side = "Left"})

local player = game.Players.LocalPlayer
local Camera = workspace.CurrentCamera
local stealm = false
local stealTask

local function StealMoneyPrompt()
    for _, v in pairs(workspace.Dollas:GetDescendants()) do
        if v:IsA("ProximityPrompt") and v.Name == "ProximityPrompt" then
            v.HoldDuration = 0
            v.RequiresLineOfSight = false
        end
    end
end

local function startStealing()
    StealMoneyPrompt()
    stealTask = task.spawn(function()
        while stealm do
            task.wait()
            local found = false

            for _, v in pairs(workspace.Dollas:GetDescendants()) do
                if v:IsA("ProximityPrompt") and v.Name == "ProximityPrompt" and stealm then
                    found = true
                    StealMoneyPrompt()
                    Camera.CFrame = CFrame.new(Camera.CFrame.Position, v.Parent.CFrame.Position)

                    local char = player.Character
                    local humanoid = char and char:FindFirstChildOfClass("Humanoid")
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    if humanoid and hrp then
                        humanoid:ChangeState(0)
                        repeat task.wait() until not player:GetAttribute("LastACPos")
                        hrp.CFrame = v.Parent.CFrame
                    end

                    task.wait(0.25)
                    fireproximityprompt(v)
                end
            end

            if not found then
                task.wait(3)
            end
        end
    end)
end

local function stopStealing()
    stealm = false
    if stealTask then
        task.cancel(stealTask)
        stealTask = nil
    end
end


FSection:Toggle({
    Name = "Collect Dropped Cash",
    Side = "Left",
    Value = false,
    Callback = function(Value)
        stealm = value
        if stealm then
            startStealing()
        else
            stopStealing()
        end
    end
})

FSection:Toggle({
    Name = "Loot Body Bags",
    Side = "Left",
    Value = false,
    Callback = function(Value)
        print("g")
        end
    })

local RSection = Tab:Section({Name = "Manual Farms", Side = "Right"})

RSection:Divider({Text = "Robberies",Side = "Right"})

local camera = workspace.CurrentCamera

function stuidoprompt()
    for _, v in pairs(workspace.StudioPay.Money:GetDescendants()) do
        if v:IsA("ProximityPrompt") and v.Name == "Prompt" then
            v.HoldDuration = 0
            v.RequiresLineOfSight = false
        end
    end
end

RSection:Button({
    Name = "Rob 'On The Radar' Studio",
    Side = "Right",
    Value = false,
    Callback = function(Value)
        local robstudio = Value

        if robstudio then
            local player = game.Players.LocalPlayer
            local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
            if not root or not humanoid then return end

            local originalCFrame = root.CFrame
            stuidoprompt()

            for _, v in pairs(workspace.StudioPay.Money:GetDescendants()) do
                if v:IsA("ProximityPrompt") and v.Name == "Prompt" and v.Enabled then
                    humanoid:ChangeState(0)
                    repeat task.wait() until not player:GetAttribute("LastACPos")

                    root.CFrame = CFrame.new(
                        v.Parent.Position.X,
                        v.Parent.Position.Y + 2,
                        v.Parent.Position.Z
                    )

                    camera.CFrame = CFrame.new(camera.CFrame.Position, v.Parent.Position)
                    task.wait(0.25)

                    repeat
                        task.wait(0.3)
                        fireproximityprompt(v)
                    until v.Enabled == false or not robstudio

                    if not robstudio then break end
                end
            end

            if robstudio then
                root.CFrame = originalCFrame
            end
        end
    end
})

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local Camera = workspace.CurrentCamera

function BypassTp(cf)
    local char = player.Character or player.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local root = char:WaitForChild("HumanoidRootPart")

    humanoid:ChangeState(0)
    repeat task.wait() until not player:GetAttribute("LastACPos")
    root.CFrame = cf
end

local Houseleft = {}
local Houseright = {}

local targetPosition = Vector3.new(-615, 254, -695)

function updateDoors()
    table.clear(Houseleft)
    table.clear(Houseright)

    for _, v in pairs(workspace.HouseRobb:GetDescendants()) do
        if (v.Name == "WoodenDoor" or v.Name == "HardDoor") and v:IsA("BasePart") and v:FindFirstChild("ProximityPrompt") then
            if (v.Position - targetPosition).Magnitude <= 10 then
                Houseright[v.Name] = v
            else
                Houseleft[v.Name] = v
            end
        end
    end
end

function HouseRobPrompts()
    for _, v in pairs(workspace.HouseRobb:GetDescendants()) do
        if v:IsA("ProximityPrompt") and v.Name == "ProximityPrompt" then
            v.HoldDuration = 0
            v.RequiresLineOfSight = false
            v.Enabled = false
        end
    end
end


RSection:Button({
    Name = "Rob Houses",
    Side = "Right",
    Value = false,
    Callback = function(Value)
        RobHouse = Value
        local OldCframe = player.Character.HumanoidRootPart.CFrame

        if RobHouse then
            HouseRobPrompts()
        end

        task.spawn(function()
            while RobHouse do
                task.wait()
                updateDoors()

                if not RobHouse then break end

                local house1Robbed = Houseleft["HardDoor"] and Houseleft["HardDoor"].Transparency == 1
                local moneyParts = Houseleft["HardDoor"] and
                Houseleft["HardDoor"].Parent.Parent:FindFirstChild("TakeMoney")
                local moneyFound = false

                if house1Robbed and moneyParts then
                    for _, part in pairs(moneyParts:GetChildren()) do
                        if part.Name == "MoneyGrab" and part.Transparency == 0 then
                            moneyFound = true
                            break
                        end
                    end
                end

                if not house1Robbed then
                    for _, v in pairs(Houseleft["HardDoor"]:GetDescendants()) do
                        if v:IsA("ProximityPrompt") and v.Name == "ProximityPrompt" then
                            v.Enabled = true
                            BypassTp(v.Parent.CFrame * CFrame.new(-1.5, 0, 0))
                            Camera.CFrame = CFrame.new(Camera.CFrame.Position, v.Parent.Position)
                            repeat
                                task.wait()
                                fireproximityprompt(v)
                            until Houseleft["HardDoor"].Transparency == 1
                        end
                    end

                    for _, v in pairs(Houseleft["HardDoor"].Parent.Parent:GetDescendants()) do
                        if v:IsA("ProximityPrompt") and v.Name == "ProximityPrompt" then
                            HouseRobPrompts()
                            local targetCFrame = v.Parent.CFrame * CFrame.new(0, 0, -3)
                            BypassTp(targetCFrame)
                            Camera.CFrame = CFrame.new(Camera.CFrame.Position, v.Parent.Position)
                            v.Enabled = true
                            repeat
                                fireproximityprompt(v)
                                task.wait()
                            until v.Parent.Transparency == 1
                            v.Enabled = false
                        end
                    end
                end

                local house2Robbed = Houseright["WoodenDoor"] and Houseright["WoodenDoor"].Transparency == 1
                local moneyParts2 = Houseright["WoodenDoor"] and
                Houseright["WoodenDoor"].Parent.Parent:FindFirstChild("TakeMoney")
                local moneyFound2 = false

                if house2Robbed and moneyParts2 then
                    for _, part in pairs(moneyParts2:GetChildren()) do
                        if part.Name == "MoneyGrab" and part.Transparency == 0 then
                            moneyFound2 = true
                            break
                        end
                    end
                end

                if not house2Robbed then
                    for _, v in pairs(Houseright["WoodenDoor"]:GetDescendants()) do
                        if v:IsA("ProximityPrompt") and v.Name == "ProximityPrompt" then
                            v.Enabled = true
                            BypassTp(v.Parent.CFrame * CFrame.new(-1.5, 0, 0))
                            Camera.CFrame = CFrame.new(Camera.CFrame.Position, v.Parent.Position)
                            repeat
                                task.wait()
                                fireproximityprompt(v)
                            until Houseright["WoodenDoor"].Transparency == 1
                        end
                    end

                    for _, v in pairs(Houseright["WoodenDoor"].Parent.Parent:GetDescendants()) do
                        if v:IsA("ProximityPrompt") and v.Name == "ProximityPrompt" then
                            HouseRobPrompts()
                            local targetCFrame = v.Parent.CFrame * CFrame.new(0, 0, -3)
                            BypassTp(targetCFrame)
                            Camera.CFrame = CFrame.new(Camera.CFrame.Position, v.Parent.Position)
                            v.Enabled = true
                            repeat
                                fireproximityprompt(v)
                                task.wait()
                            until v.Parent.Transparency == 1
                            v.Enabled = false
                        end
                    end
                end

                BypassTp(OldCframe)
                break
            end
        end)
    end
})

RSection:Button({
    Name = "Rob Bank",
    Side = "Right",
    Value = false,
    Callback = function(Value)
      print("ha")
        end
    })

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local Tab = Window:Tab({Name = "Players"})
local PSection = Tab:Section({Name = "Players", Side = "Left"})

local playerOptions = {}
local selectedPlayers = {}
local bringStates = {}
local isSpectating = false
local originalCameraSubject
local isLoopingAttack = false
local attackLoop
local selectedPlayer

local function getCharacter()
    return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
end

local function safeTeleport(x, y, z)
    local humanoid = getCharacter():FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid:ChangeState(0)
    end
    repeat task.wait() until not LocalPlayer:GetAttribute("LastACPos")
    getCharacter():WaitForChild("HumanoidRootPart").CFrame = CFrame.new(x, y, z)
end

local function updatePlayerOptions()
    playerOptions = {}
    for _, p in ipairs(Players:GetPlayers()) do
        table.insert(playerOptions, {
            Name = p.Name,
            Mode = "Toggle",
            Value = false,
            Callback = function(selected)
                if selected then
                    selectedPlayers[p.Name] = true
                    selectedPlayer = p
                else
                    selectedPlayers[p.Name] = nil
                    if selectedPlayer and selectedPlayer.Name == p.Name then
                        selectedPlayer = nil
                    end
                end
            end
        })
    end
end

updatePlayerOptions()

local Dropdown = PSection:Dropdown({
    Name = "Select Player",
    Side = "Left",
    Default = {},
    List = playerOptions
})

Players.PlayerAdded:Connect(function()
    updatePlayerOptions()
    Dropdown:Clear()
    for _, v in ipairs(playerOptions) do
        Dropdown:AddOption(v)
    end
end)

Players.PlayerRemoving:Connect(function()
    updatePlayerOptions()
    Dropdown:Clear()
    for _, v in ipairs(playerOptions) do
        Dropdown:AddOption(v)
    end
end)

PSection:Divider({Text = "Options",Side = "Left"})

PSection:Button({
    Name = "Down Player",
    Side = "Left",
    Callback = function()
        isLoopingAttack = not isLoopingAttack

        if isLoopingAttack then
            attackLoop = task.spawn(function()
                while isLoopingAttack do
                    if selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local pos = selectedPlayer.Character.HumanoidRootPart.Position

                        local character = getCharacter()
                        local backpack = LocalPlayer:FindFirstChild("Backpack")
                        local fist = character:FindFirstChild("Fist") or (backpack and backpack:FindFirstChild("Fist"))

                        if fist then
                            if backpack and backpack:FindFirstChild("Fist") then
                                fist.Parent = character
                            end

                            local attackRemote = character:FindFirstChild("Fist"):FindFirstChild("MeleeSystem"):FindFirstChild("AttackEvent")
                            if attackRemote then
                                for _ = 1, 40 do
                                    attackRemote:FireServer()
                                    task.wait()
                                end
                            end
                        end

                        safeTeleport(pos.X, pos.Y, pos.Z)
                    end
                    task.wait(0.2)
                end
            end)
        else
            if attackLoop then
                task.cancel(attackLoop)
                attackLoop = nil
            end
        end
    end
})

PSection:Button({
    Name = "Bring Player",
    Side = "Left",
    Callback = function()
        for playerName, _ in pairs(selectedPlayers) do
            local targetPlayer = Players:FindFirstChild(playerName)
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local root = targetPlayer.Character.HumanoidRootPart
                if not bringStates[playerName] then
                    bringStates[playerName] = root.CFrame
                    root.CFrame = LocalPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(2, 0, 0)
                else
                    root.CFrame = bringStates[playerName]
                    bringStates[playerName] = nil
                end
            end
        end
    end
})

PSection:Button({
    Name = "Teleport To Player",
    Side = "Left",
    Callback = function()
        for playerName, _ in pairs(selectedPlayers) do
            local targetPlayer = Players:FindFirstChild(playerName)
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid:ChangeState(0)
                end
                repeat task.wait() until not LocalPlayer:GetAttribute("LastACPos")
                LocalPlayer.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame
                break
            end
        end
    end
})



PSection:Button({
    Name = "Spectate Player",
    Side = "Left",
    Callback = function()
        if isSpectating then
            Camera.CameraSubject = originalCameraSubject
            isSpectating = false
        else
            for playerName, _ in pairs(selectedPlayers) do
                local targetPlayer = Players:FindFirstChild(playerName)
                if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Humanoid") then
                    originalCameraSubject = Camera.CameraSubject
                    Camera.CameraSubject = targetPlayer.Character:FindFirstChild("Humanoid")
                    isSpectating = true
                    break
                end
            end
        end
    end
})

PSection:Divider({Text = "Kill Method",Side = "Left"})

PSection:Button({
    Name = "Kill Player w/Fist",
    Side = "Left",
    Callback = function()
        isLoopingAttack = not isLoopingAttack

        if isLoopingAttack then
            attackLoop = task.spawn(function()
                while isLoopingAttack do
                    if selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local pos = selectedPlayer.Character.HumanoidRootPart.Position

                        local character = getCharacter()
                        local backpack = LocalPlayer:FindFirstChild("Backpack")
                        local fist = character:FindFirstChild("Fist") or (backpack and backpack:FindFirstChild("Fist"))

                        if fist then
                            if backpack and backpack:FindFirstChild("Fist") then
                                fist.Parent = character
                            end

                            local attackRemote = character:FindFirstChild("Fist"):FindFirstChild("MeleeSystem"):FindFirstChild("AttackEvent")
                            if attackRemote then
                                for _ = 1, 40 do
                                    attackRemote:FireServer()
                                    task.wait()
                                end
                            end
                        end

                        safeTeleport(pos.X, pos.Y, pos.Z)
                    end
                    task.wait(0.2)
                end
            end)
        else
            if attackLoop then
                task.cancel(attackLoop)
                attackLoop = nil
            end
        end
    end
})

local ASection = Tab:Section({Name = "Troll", Side = "Left"})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CallPolice = ReplicatedStorage:WaitForChild("CallPolice")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local policeSpamming = false
local policeTask

ASection:Toggle({
    Name = "Spam Call Police",
    Value = false,
    Callback = function(value)
        policeSpamming = value
        if policeSpamming then
            policeTask = task.spawn(function()
                while policeSpamming do
                    CallPolice:FireServer()
                    task.wait(0.1)
                end
            end)
        else
            if policeTask then
                task.cancel(policeTask)
                policeTask = nil
            end
        end
    end
})

local messageToSend = ""
local tweetSpamming = false
local tweetDelay = 10

local function sendTweet()
    if messageToSend ~= "" then
        local args = {
            "Tweet",
            {
                "CreateTweet",
                messageToSend
            }
        }
        ReplicatedStorage:WaitForChild("Resources"):WaitForChild("#Phone"):WaitForChild("Main"):FireServer(unpack(args))
    end
end

ASection:Textbox({
    Name = "Tweet Message",
    Text = "",
    Placeholder = "X-Dk on top",
    NumberOnly = false,
    Callback = function(input)
        messageToSend = input
        sendTweet()
    end
})

ASection:Slider({
    Name = "Spam Tweets Delay",
    Min = 0,
    Max = 10,
    Value = 10,
    Precise = 1,
    Unit = "s",
    Callback = function(value)
        tweetDelay = value
    end
})

ASection:Toggle({
    Name = "Spam Tweets",
    Value = false,
    Callback = function(value)
        tweetSpamming = value
        if tweetSpamming then
            task.spawn(function()
                while tweetSpamming do
                    sendTweet()
                    task.wait(tweetDelay)
                end
            end)
        end
    end
})

getgenv().highlightdestroy = true
getgenv().damage = math.huge

function checkgun()
    for _, tool in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
        if tool:IsA("Tool") and tool.Name:lower():find("gun") then
            return tool
        end
    end
    return nil
end

function getpaint(car)
    return car.PrimaryPart or car:FindFirstChildWhichIsA("BasePart")
end

function DamageAllVehicles()
    local gunTool = checkgun()
    if not gunTool then return end
